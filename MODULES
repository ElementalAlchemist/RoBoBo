RoBoBo-IRC-BoBo
Creating Modules Help File
=======================
Table of Contents

1. Current API
2. Specifics of Implementation
3. Communicating with a Server
- 3.1. Receiving Data from a Server
- 3.2. Receiving Data Being Sent to a Server
- 3.3. Other Hooks
- 3.4. Sending Data to a Server
4. Helpful Variables and Functions
5. Interacting With Other Modules

=======================
1. CURRENT API

The current API version is 1.0.2.

int ModuleClass::botAPIversion() {
	return 1002;
}

Version 1.0.2 of the API is incompatible with 1.0.1 and 1.0.0, both of which
were used in the beta versions of 1.0.
Module-breaking changes to the API are avoided starting with the release
candidate.  The API version in use as of 1.0.0RC1 was 1.0.2.

=======================
2. SPECIFICS OF IMPLEMENTATION

In order to interface with the bot, you will need to define a few things.

First, you will need to make a C++ file which includes some data from the bot.
This file should be placed in the src/modules/ directory.  You'll need to
include the bot information as such:

#include "modinclude.h"

This allows your class to extend the Module class and access other necessary
classes.

Second, you will need functions allowing the bot to load your module.  This is
internally known as "spawning," mostly because "spawn" is such a cool word.  In
order for the bot to load your module, you must define a way to load your
module.  This is done most simply as such:

extern "C" Module* spawn() {
	return new mod_name;
}

In this snippet, the only thing that should change is the returned class in the
spawn() function, which must be changed from mod_name to the name of your
module class.  This must be placed after your class definition.  If you think
you will forget about it, write it first, and then just define the class above
it.

Now that you've defined those, you are ready to make your class!  Your class
must extend the Module class.

class mod_name : public Module {
// Look!  A module!
};

If you wish you may write a constructor for your modules to initialize class
variables.  No parameters are passed to the constructor, and, as such, there is
not access to bot functions in the constructor.  Use onLoadComplete() instead
(see below, section 3.3), which the bot calls once your module has been loaded
(or if your module is loaded at startup, after all modules have been loaded).

Finally, the Module class contains a pure virtual function, botAPIversion().
This function must return an integer corresponding to the version of the bot
API with which your module complies.  Information about the current API version
is listed in section 1, above.

From here you have the skeleton of your module.  The rest of this document
outlines information you may want to know such as how to receive and be able to
parse data from IRC servers, and how to send data to IRC servers.

=======================
3. COMMUNICATING WITH A SERVER

As a module for an IRC bot, you can expect to be able to communicate with the
servers the bot is connected to.  The subsections that follow describe how to
catch received and sent messages so that you can react to them as well as how
to send messages from your module.

=======================
3.1. RECEIVING DATA FROM A SERVER

One direction of communication is receiving data.  This is provided through
what the bot calls "hooks."  In order to use hooks you must simply define the
functions corresponding to the hooks you need, which are declared as virtual in
the base Module class.

void onChannelMsg(std::string server, std::string channel, char target, std::string nick, std::string message);
	This function is called when a PRIVMSG is received through a channel.  It is not triggered on CTCP.
		server: The server from which the message was received
		channel: The channel through which the message was received
		target: The status character of the nicks who received the message.  If none, target == '0'
		nick: The nick the message is from
		message: The contents of the message
void onUserMsg(std::string server, std::string nick, std::string message);
	This function is called when a PRIVMSG is received directly from a user.  It is not triggered on CTCP.
		server: The server from which the message was received
		nick: The nick the message is from
		message: The contents of the message
void onChannelNotice(std::string server, std::string channel, char target, std::string nick, std::string message);
	This function is called when a NOTICE is received through a channel.  It is not triggered on CTCP reply.
		server: The server from which the notice was received
		channel: The channel through which the message was receivied
		target: The status character of the nicks who received the message.  If none, target == '0'
		nick: The nick the notice is from
		message: The contents of the message
void onUserNotice(std::string server, std::string nick, std::string message);
	This function is called when a NOTICE is received directly from a user.  It is not triggered on CTCP reply.
		server: The server from which the notice was received
		nick: The nick the notice is from
		message: The contents of the message
void onChannelAction(std::string server, std::string channel, char target, std::string nick, std::string message);
	This function is called when a CTCP ACTION is received through a channel.
		server: The server from which the action was received.
		channel: The channel through which the action was received
		target: The status character of the nicks who received the action.  If none, target == '0'
		nick: The nick the action is from
		message: The contents of the action message
void onUserAction(std::string server, std::string nick, std::string message);
	This function is called when a CTCP ACTION is received directly from a user.
		server: The server from which the action was received
		nick: The nick the action is from
		message: The contents of the action message
void onChannelCTCP(std::string server, std::string channel, char target, std::string nick, std::string message);
	This function is called when a CTCP request (except ACTION) is received through a channel.
		server: The server from which the request was received
		channel: The channel through which the request was received
		target: The status character of the nicks who received the request.  If none, target == '0'
		nick: The nick the request is from
		message: The contents of the request, including the type and any other data
void onUserCTCP(std::string server, std::string nick, std::string message);
	This function is called when a CTCP request (except ACTION) is received directly from a user.
		server: The server from which the request was received
		nick: The nick the request is from
		message: The contents of the request, including the type and any other data
void onChannelCTCPReply(std::string server, std::string channel, char target, std::string nick, std::string message);
	This function is called when a CTCP reply is received through a channel.
		server: The server from which the reply was received
		channel: The channel through which the reply was received
		target: The status character of the nicks who received the reply.  If none, target == '0'
		nick: The nick the reply is from
		message: The contents of the reply, including the type and any other data
void onUserCTCPReply(std::string server, std::string nick, std::string message);
	This function is called when a CTCP reply is received directly from a user.
		server: The server from which the reply was received
		nick: The nick the reply is from
		message: The contents of the reply, including the type and any other data
void onChannelJoin(std::string server, std::string channel, std::string hostmask);
	This function is called when someone joins a channel.  This can be the bot or anyone else.
		server: The server from which the JOIN was received
		channel: The channel that was joined
		hostmask: The hostmask of the user who joined
void onChannelPart(std::string server, std::string channel, std::string hostmask, std::string reason);
	This function is called when someone parts a channel.  This can be the bot or anyone else.
		server: The server from which the PART was received.
		channel: The channel that was parted
		hostmask: The hostmask of the user who parted
		reason: The part reason
void onUserQuit(std::string server, std::string hostmask, std::string reason);
	This function is called when someone quits the IRC server.  This can be the bot or anyone else.
		server: The server from which the QUIT was received.
		hostmask: The hostmask of the user who quit
		reason: The quit message
void onNickChange(std::string server, std::string oldNick, std::string newNick);
	This function is called when someone changes his/her nick.  This can be the bot or anyone else.
	If the bot is changing names, this hook is called before the bot's nick is internally modified.
		server: The server from which the NICK was received
		oldNick: The former nick of the user
		newNick: The new nick of the user
void onChannelKick(std::string server, std::string channel, std::string kicker, std::string kickee, std::string reason);
	This function is called when someone is kicked from an IRC channel.
		server: The server from which the KICK was received
		channel: The channel a user was kicked from
		kicker: The nick of the user who kicked
		kickee: The nick of the user who was kicked
		reason: The kick reason
void onChannelMode(std::string server, std::string channel, std::string setter, char mode, bool add, std::string param);
	This function is called when someone sets a mode on an IRC channel.
		server: The server from which the MODE was received
		channel: The channel in which the mode was set
		setter: The user who set the mode
		mode: The mode character
		add: TRUE if the mode was added and FALSE if the mode was removed
		param: Any parameters with the mode; empty string if there were no parameters
void onNumeric(std::string server, std::string numeric, std::vector<std::string> parsedLine);
	This function is called when the bot receives a numeric from the server.
		server: The server that sent the numeric
		numeric: The numeric
		parsedLine: The entire line parsed as IRC parameters.
			parsedLine[0]: The server's name preceded with a colon
			parsedLine[1]: The numeric
			parsedLine[2+]: All the parameters of the numeric
void onOtherData(std::string server, std::vector<std::string> parsedLine);
	This function serves as a catch-all function.  All lines that don't call other hooks call this one.
		server: The server the line was received from
		parsedLine: The entire line parsed as IRC parameters
			parsedLine[0]: The server's name or sender's hostmask, preceded with a colon
			parsedLine[1]: The command
			parsedLine[2+]: Any parameters to the command

=======================
3.2 RECEIVING DATA BEING SENT TO A SERVER

Some hooks are defined to catch outgoing data, as well.  These hooks will be
called when a matching line is sent, even if the hook being called belongs to
the module that sent the line.  Outgoing hooks are not defined for data that is
returned when successful (i.e. MODE, etc.).

void onOutChannelMessage(std::string server, std::string target, char status, std::string message);
	This function is called whenever the bot sends a PRIVMSG to a channel.
		server: The server the line was sent to
		target: The channel the line was sent to
		status: The status level the line was sent to.  If there is none, target == '0'
		message: The actual message
void onOutUserMessage(std::string server, std::string target, std::string message);
	This function is called whenever the bot sends a PRIVMSG to a user.
		server: The server the line was sent to
		target: The nick the line was sent to
		message: The actual message
void onOutChannelNotice(std::string server, std::string target, char status, std::string message);
	This function is called when the bot sends a notice to the channel.
		server: The server the line was sent to
		target: The channel the line was sent to
		status: The status level the line was sent to.  If there is none, target == '0'
		message: The actual message
void onOutUserNotice(std::string server, std::string target, std::string message);
	This function is called when the bot sends a notice to a user.
		server: The server the line was sent to
		target: The nick the line was sent to
		message: The actual message
void onOutChannelAction(std::string server, std::string target, char status, std::string message);
	This function is called when the bot sends a CTCP ACTION to a channel.
		server: The server the line was sent to
		target: The channel the line was sent to
		status: The status level the line was sent to.  If there is none, target == '0'
		message: The action message
void onOutUserAction(std::string server, std::string target, std::string message);
	This function is called when the bot sends a CTCP ACTION to a user.
		server: The server the line was sent to
		target: The nick the line was sent to
		message: The action message
void onOutChannelCTCP(std::string server, std::string target, char status, std::string message);
	This function is called when the bot sends a CTCP request to a channel.
		server: The server the CTCP request was sent to
		target: The channel the CTCP request was sent to
		status: The status level the line was sent to.  If there is none, target == '0'
		message: The actual CTCP request, including the type and other sent data
void onOutUserCTCP(std::string server, std::string target, std::string message);
	This function is called when the bot sends a CTCP request to a user.
		server: The server the CTCP request was sent to
		target: The nick the CTCP request was sent to
		message: The actual request, including the type and other sent data
void onOutChannelCTCPReply(std::string server, std::string target, char status, std::string message);
	This function is called when the bot sends a CTCP reply to a channel.
		server: The server the CTCP reply was sent to
		target: The channel the CTCP reply was sent to
		status: The status level the line was sent to.  If there is none, target == '0'
		message: The actual CTCP reply, including the type and other given information
void onOutUserCTCPReply(std::string server, std::string target, std::string message);
	This function is called when the bot sends a CTCP reply to a user.
		server: The server the CTCP reply was sent to
		target: The user the CTCP reply was sent to
		message: The actual reply, including the type and any given information

=======================
3.3. OTHER HOOKS

There are some other hooks, too.  When they are called depends on the hook.

void onLoadComplete();
	This function is called once all modules are loaded.  Modules will have the config and bot access loaded before this call.
void onRehash();
	This function is called when the bot is rehashed or when a module is loaded or unloaded.  Modules will have an updated config loaded before this call.
void onConnect(std::string server);
	This function is called when the bot connects to a server.
void onQuit(std::string server);
	This function is called when the bot quits from a server.

=======================
3.4. SENDING DATA TO A SERVER

Some functions are provided to you free of charge in the Module class allowing
you to easily perform certain actions.

void sendPrivMsg(std::string server, std::string target, std::string message);
	This function will send a message.
		server: The server the message is to be sent to
		target: The recipient of the message.  Either a nick or a channel.
		message: The message you wish to send.
void sendNotice(std::string server, std::string target, std::string message);
	This function will send a notice.
		server: The server the message is to be sent to
		target: The recipient of the notice.  Either a nick or a channel.
		message: The message you wish to send.
void sendCTCP(std::string server, std::string target, std::string type, std::string params = "");
	This function will send a CTCP request.
		server: The server the CTCP is to be sent to.
		target: The recipient of the CTCP request.
		type: The type of CTCP you are sending (PING, VERSION, etc.)
		params: Optional. Any data that should be sent with the CTCP request.
void sendCTCPReply(std::string server, std::string target, std::string type, std::string data = "");
	This function will send a CTCP reply.
		server: The server the reply is to be sent to.
		target: The recipient of the CTCP reply.
		type: The type of reply you are sending (PING, VERSION, etc.)
		params: Optional. Any data that should be sent with the CTCP reply.
void joinChannel(std::string server, std::string channel, std::string key = "");
	This function will make the bot join a channel.
		server: The server of the channel the bot should be joining
		channel: The channel to join
		key: Optional. The key of the channel the bot is to join
void partChannel(std::string server, std::string channel, std::string reason);
	This function will make the bot part a channel.
		server: The server of the channel the bot should part
		channel: The channel the bot should part
		reason: The part message
void kickChannelUser(std::string server, std::string channel, std::string nick, std::string reason);
	This function will make the bot kick someone in a channel.
		server: The server on which the user you wish to kick is
		channel: The channel to kick a user from
		nick: The nick to kick from the channel
		reason: The kick reason
void setMode(std::string server, std::string channel, char mode, bool add, std::string param = "");
	This function will make the bot set a mode on a channel.
		server: The server the channel is on
		channel: The channel the mode is to be set on
		mode: The mode character you wish to setMode
		add: TRUE if you wish to set the mode, FALSE if you wish to remove it
		param: Optional. The parameter for the mode
void sendOtherCommand(std::string server, std::string command, std::string data);
	This function allows you to send any command not specified by another function.
		server: The server to send the command to
		command: The command itself
		data: Any parameters for the command.  The command and data are separated by a space.
bool connectServer(std::string server);
	This function allows you to connect the bot to a server.  It returns true if it could connect, or false if it couldn't.
		server: The server to connect to
void quitServer(std::string server, std::string reason);
	This function makes the bot quit a server.
		server: The server to quit
		reason: The quit reason to give

=======================
4. HELPFUL VARIABLES AND FUNCTIONS

The Module class contains some functions that make it possible to code many
modules and other functions that are just helpful.

std::string moduleName;
This variable contains the name for the module as known internally by the bot.
It's also the bot's filename.

unsigned short debugLevel;
The debug level the bot was started with.  This allows you to have your module
output debug info based on the debug level the bot was started with.

std::tr1::unordered_map<std::string, std::string> config;
This variable contains all of the variables that correspond to the module and
the values that the variables have as defined in the configuration file.  The
map key is the specified variable, and the map value is the variable's
configured definition.

void rehashBot();
This function causes the bot to reload the configuration file and call
onRehash() for all loaded modules.

unsigned int getBotVersion();
This function returns the version number of the bot core, in this format:
1001 = 1.0.1
1010 = 1.0.10
1102 = 1.1.2

std::list<std::string> getServers()
This function returns a list of valid server names.  It gives the names of all
connected servers.

std::tr1::unordered_map<std::string, Module*> getModules()
This function returns currently loaded modules.  This is useful if you want
your module to interact with another module.

std::multimap<std::string, std::string> getModAbilities();
This function returns a list of module abilities.  This multimap works as
follows:
first = provided ability
second = module name

std::vector<std::string> splitHostmask(std::string hostmask)
This function takes a hostmask.  The hostmask can be either in the form of a
normal nick!user@host hostmask or taken directly from a parsedLine[0] (or any
other variable that may contain a line split up in that fashion).
It returns a vector with the nick in position 0, the ident in position 1, and
the hostname in position 2.

std::vector<std::string> splitBySpace(std::string line)
This function takes any line, and it splits it into pieces using a space as a
delimiter.  Each word gets one position in the vector in the order in which the
word was found.

std::tr1::unordered_map<std::string, std::string> getServerData(std::string server);
This function returns the conf data held by the server class.  Any part of the
configuration may be updated by the Server class during normal use (such as
nick).

std::vector<std::vector<char> > getServerChanModes(std::string server);
This function returns all valid channel modes for the server as specified in
005 CHANMODES.  The outer vector has four elements, split by 005 CHANMODES's
commas:
0 => list modes
1 => modes that need a parameter to both set and unset (like +k)
2 => modes that take a parameter but do not require it to unset
3 => modes with no parameters
The inner vectors are as long as necessary to hold all the modes of that type.

std::tr1::unordered_map<char, char> getServerPrefixes(std::string server);
This function returns all valid prefix/status modes for the server as specified
in 005 PREFIX.  Each entry in the map holds two characters:
first => mode char
second => status prefix char

std::list<std::string> getChannels(std::string server);
This function returns a list of the names of all the channels the bot is in on
the specified server.

std::string getChannelTopic(std::string server, std::string channel);
This function returns the topic of the specified channel on the specified
server, if the bot is in it.

std::list<std::string> getChannelUsers(std::string server, std::string channel);
This function returns a list of all users in the specified channel on the
specified server, if the bot is in it.

std::pair<char, char> getUserStatus(std::string server, std::string channel, std::string user);
This function returns the status of the specified user in the specified channel
on the specified server, if both the bot and the user are in that channel.  The
returned status is in this form:
first => mode char
second => status prefix char

=======================
5. INTERACTING WITH OTHER MODULES

Interacting with modules using functions that are not part of the Module class
requires the use of a custom class in a header file in the modules/ directory.
A module must extend the class in the header file in order to provide those
functions to other modules.  A module that takes advantage of another module's
functionality must have the header file present to compile, regardless of
whether the module that provides the functions your module is using is present
when the bot is run.

If your module relies on the presence of another module, you should check for
the other module in both onLoadComplete() AND onRehash().